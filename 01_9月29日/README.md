# 1. この授業では何をするのか
## 1.0 概要
- 教科書：コンピュータシステムの理論と実装（オライリー社）
## 1.1 モチベーション
- 1年生の情報システムの実験では，ライントレーサーを開発した
	- 前期はGUIでのプログラム構築，後期はCUIでのプログラム構築
- 2年生の前期・プログラミング基礎ではPython言語を用いて，文字通り「プログラムの基礎」を学んだ
- 一方，情報リテラシー等の科目ではコンピュータの使い方を学んだ
- 諸君らは”情報システムコース”を名乗る以上，情報を支える基盤技術たるコンピュータの仕組みを理解すべきである
- では，コンピュータの仕組みを理解するための最善の方法はなんだろうか？
	- それはコンピュータをゼロから作ることである
- **これから2I「計算機システム」，3I「システムプログラムI・II」の1年半を掛けて，コンピュータをゼロから作ることでコンピュータの仕組みを理解することが，本講義の最大の目的である**
- 特に2I「計算機システム」では教科書5章までを題材に，コンピュータアーキテクチャに関する話題まで取り組む
## 1.2 コンテンツ
1年半を通じて，下記の内容について理解する
- ハードウェア
	- ブール演算、組み合わせ論理回路、順序論理回路、論理ゲートの設計と実装、マルチプレクサ、フリップフロップ、レジスタ、RAM、カウンタ、ハードウェア記述言語（Hardware Description Language; HDL）、回路シミュレーション、回路テスト
- アーキテクチャ
	- ALU/CPU の設計と実装、クロックとサイクル、アドレッシングモード、フェッチと実行の論理、命令セット、メモリマップド I/O
- 低水準言語
	- 機械語 (バイナリ形式) の設計と実装、命令セット、アセンブリ言語、アセンブリ言語でのプログラミング、アセンブラ
- 仮想マシン
	- スタックベースのオートマトン、スタック演算、関数の呼び出しと復帰、再帰処理、単純な仮想マシン言語の設計と実装
- 高水準言語
	- 単純なオブジェクトベース言語（Java のような言語）の設計と実装：抽象データ型、クラス、コンストラクタ、メソッド、スコープルール、構文とセマンティクス、参照
- コンパイラ
	- 字句解析、構文解析、シンボルテーブル、コード生成、配列とオブジェクトの実装、2 段階コンパイルプログラミングアセンブラ、仮想マシン（Virtual Machine; VM）、コンパイラの実装（使用するプログラミング言語は任意）
- オペレーティングシステム
	- メモリ管理、数学ライブラリ、入出力ドライバ、文字列処理、テキスト・グラフィカル要素のレンダリング、高水準言語のサポート
- データ構造とアルゴリズム
	- スタック、ハッシュテーブル、リスト、木構造、算術アルゴリズム、幾何アルゴリズム、処理時間の検討
- ソフトウェアエンジニアリング
	- モジュール設計、インターフェース/実装パラダイム、API デザインとドキュメント、ユニットテスト、将来を見据えたテスト設計、品質保証、大規模プロジェクト
# 第I部：ハードウェア
## I.1 Hello, World Below（P.2）／ I.2 Nand to Tetris（P.3）
```
// リスト1
class Main {
    function void main(){
	    do Output.printSting("Hello World");
	    return;
    }
}
```
- 上記のプログラムは，人間が読んでもなんとなく理解できる
	- Hello Worldと画面に表示するプログラム
- 一方で，コンピュータは機械語で書かれた命令しか理解できない
	- ということは，アルファベットやテキストで書かれたリスト1のプログラムをコンピュータは理解できない

- プログラムをコンピュータに理解させるには，下記のエッセンスが必要である
	1. **コンパイル**：プログラムに書かれている構文を解析し、その内容を明らかにした上で、コンピュータが理解できる低水準言語に変換する作業．これによって、コンピュータで実行可能な**機械語**の命令列が生み出される。
	2. **機械語**もまた抽象化されたものである。機械語の中身は、ある規則に基づくバイナリデータの集合である。この抽象化を具現化するには、なんらかの**ハードウェアアーキテクチャ**が必要になる。
	3. そのアーキテクチャの実装には、いくつかのチップ――レジスタ、メモリ、ALU など――が用いられる。
	4. さらに、それらのハードウェアデバイスはどれもがすべて、より低水準の**基本論理ゲート**から構成される。
	5. そして、それらのゲートは**NANDやNORなどのより単純なゲートから構築**することができる。
	6. さらに、それらの単純なゲートも階層的にはかなり低水準ではあるが、スイッチング素子から作られており、**スイッチング素子は一般的にトランジスタ**によって作られる。
- これらを図示すると図1のようになる


![](materials/Pasted%20image%2020250830171840.png)
<center>図 I-1 典型的なコンピュータシステムの主要なモジュールの構成．数字は教科書の章番号を示す</center>


> [!CAUTION]
> 課題01 - 問題(a)：図I-1について，各語彙について調べなさい

## I.3 抽象化と実装（P.5）／I.4 方法論（P.7）
- 読者の中には、「果たして完全なコンピュータシステムをゼロから作り上げることが可能だろうか？」と疑問に思った方もいるかもしれない。
	- 最初に使える材料はNandなどのゲートだけ
	- 複雑さに対して**モジュールに分割する**ことで対処する
		- 具体的には，モジュールに抽象化・実装する
- **抽象化**：「モジュールが何をするか（What）」を記述する
- **実装**：「それをどのように行うのか（How）」を記述する
- 例を挙げる
	- ブール論理（And、Or、Not、Xor）を実装する
		- これらは全てNandの組み合わせで実装できる
	- CPU、コンピュータを実装する
		- RAM（ランダムアクセスメモリ）を含む、下の階層にあるモジュールが使われる。
		- RAM には何十億ものレジスタがあるが、そのうちのどれにでも直接に、一瞬でアクセスできる。
		- アーキテクチャの設計者は**RAM を抽象化して使うべき**であり，**RAMがどのように実装されているかは考えなくてよい**。
	- RAMを実装する
		- RAMの実装はその下の階層にある初歩的な論理ゲートとチップをベースにしている．
			- 具体的には、RAM のデータ記憶やダイレクトアクセスの機能は、レジスタとマルチプレクサを使って実現できる。
			- このとき、**レジスタとマルチプレクサは抽象化されたモジュールとして使用できる**。つまり、そのインターフェースに焦点を当て、その**実装については何も気にする必要はない**。
	- このようにして、Nand ゲートに至るまで同じ作業が繰り返される．
- これらのゲートやチップは**ハードウェア記述言語（Hardware Description Language; HDL）** を使って記述する．

## I.5 この先の展望（P.8）
- 1章：Nandゲートから始め、And、Or、Xorゲートなどの初歩的でよく使われる論理ゲートを作る
- 2章・3章：それらの構成要素を使って、ALU（算術論理ユニット）とメモリデバイ スを作る
- 4章：ハードウェアを作る旅を一時中断し、記号形式とバイナリ形式 の機械語を紹介する
- 5章：ALU とメモリデバイスを使ってCPU（中央処理装置）とRAM（ランダムアクセスメモリ）を作る
	- そしてCPUとRAMを用いて、4 章で紹介した機械語のプログラムを実行できる汎用コンピュータを作成する
- 6章：記号形式の機械語で書かれた低水準のプログラムを実行可能なバイナリコードに変換するプログラムであるアセンブラについて説明し、その実装を行う